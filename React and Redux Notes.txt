
*** ReactJS *** (v16)

https://tylermcginnis.com/react-interview-questions/

___________________________________________________________________________________________________________________________________________

** Features of React **
- Virtual DOM.
- Server-side scripting.
- One-way data binding.
- JSX.

___________________________________________________________________________________________________________________________________________

* Advantages of React over Angular:
- In Angular, updating DOM is expensive. This is because, it works on the real DOM unlike React, which works on Virtual DOM.
- In React, it's easier to debug. This is because, it follows uni-directional data flow unlike Angular, which follows bi-directional.
- React consumes less memory, unlike Angular.

___________________________________________________________________________________________________________________________________________

* Angular vs. React:
- Two-way data binding. - One-way data binding.
- Bi-directional data flow. - Uni-directional data flow.
- Real DOM. - Virtual DOM. 
- MVC. - V.
- Client-side. -  Server-side.

___________________________________________________________________________________________________________________________________________


- React follows V pattern. 
- It doesn't allow the HTML elements to change the value.

___________________________________________________________________________________________________________________________________________

** Limitations of React **

- It's just a library, not a framework.

___________________________________________________________________________________________________________________________________________

** JSX **

- Fullform: JavaScript Extension.
- JavaScript that looks like HTML.
- It's just HTML-like syntax. Syntactical sugar.
- It's totally optional to use it.
- Compiles down to JavaScript.

___________________________________________________________________________________________________________________________________________

* props:
- It's shorthand for properties.
- It's a way of passing data from parent component to child component.
- It establishes the communication channel between the parent and child components.
- It's read-only (immutable).

___________________________________________________________________________________________________________________________________________

* state:
- It's just a JS object. 
- It's the local scope a react component.
- It stores the data of a react component.
- It's mutable.

___________________________________________________________________________________________________________________________________________

* props vs. state:
- immutable. - mutable.

_________________________________________________________________________________________________________________________________________

** super() in React **

- super() call is needed if you want to use "this" inside the constructor.
- super(props) call is needed if you want to use "this.props" inside the constructor.
- super(props) is optional in React.
- constructor() is optional in React.
- super() is required inside constructor.
___________________________________________________________________________________________________________________________________________

* Binding in React:

- React doesn't auto-bind "this" in ES 6 classes.
- We need to manually bind "this" value.

* Three approaches for binding manually:
1. Using bind() method inlinely.
2. Using bind() method in the constructor and
3. Using arrow function inlinely.

___________________________________________________________________________________________________________________________________________

* Class components or Stateful components or Container components or Smart components.
* Functional components or Stateless components or Presentational components or Dumb components. 

___________________________________________________________________________________________________________________________________________

* Class components vs.  Functional components:
 
___________________________________________________________________________________________________________________________________________

* Advantages of Functional components over Class components:

- Easy to write and understand.
- Very easy to test.
- "this" is not needed.

___________________________________________________________________________________________________________________________________________

* Disdvantages of Functional components over Class components:

- No state.
- We can't use life-cycle methods.
- We can't use refs.
- We can't connect to redux store.

___________________________________________________________________________________________________________________________________________

* Refs *

- shorthand for references.
- These are the attributes that used to store the reference to a particular node of DOM tree.
- Get the access to a DOM element.

* Uses of refs *
- Manging the focus of a text field.

___________________________________________________________________________________________________________________________________________

** React Component Lifecycle **

* Phases of component lifecycle:
1. Initialization.
2. Mounting.
3. Updation.
4. Unmounting.

1. Initialization phase: 
- Initialization of state and give the defaultProps.
- Done in constructor() method.

2. Mounting phase:
- The react component will get mounted in the browser DOM.
- componentWillMount() --> render() --> componentDidMount().

3. Updation phase:
* A component can be updated in two ways:
(a) Sending new props from the parent.
- componentWillReceiveProps() --> shouldComponentUpdate() --> componentWillUpdate() --> render() --> componentDidUpdate().

(b) Calling setState() method.
- shouldComponentUpdate() --> componentWillUpdate() --> render() --> componentDidUpdate().

4. Unmounting phase:
- The component will get removed from the DOM.
 
___________________________________________________________________________________________________________________________________________

** Life-cycle Hook Methods **

* componentWillMount() :
- This method gets executed just before the component gets mounted in the DOM i.e. just before the first render .
- API calls shouldn't be placed in this method.
- This method is very similar to constructor() method.

* render():
- This method mounts the component in the DOM tree.

* componentDidMount():
- This method gets executed after the component is mounted in the DOM.
- API calls should be placed in this method.

* componentWillReceiveProps():
- This method gets executed when the parent sends new props. 
- The new props may be assigned to the state in this method (to maintain the synchronization).

* shouldComponentUpdate():
- It determines if the component should be re-rendered.
- It can prevent the re-rendering of a component, thereby optimizing the performance.
- It returns a boolean value. 
- By default, it returns true. 


* componentWillUpdate():
- This method gets executed if shouldComponentUpdate() returns true and just before the second render.

* componentDidUpdate():
- This method gets executed after the second render.

* componentWillUnmount():
- This method gets executed just before the component is removed from the DOM.

__________________________________________________________________________________________________________________________________________

** setState() **

- It's an asynchronous operation.
- If there are many setState() calls one after the other, we won't get the expected result.
- So, to avoid this race condition, setState((prevState => {}) should be used.
___________________________________________________________________________________________________________________________________________

** Virtual DOM **

- In general, updating DOM is expensive (time-taking) i.e. slow.
- Virtual DOM is a copy of Real DOM.
- React doesn't update the Real DOM directly. First, it updates the Virtual DOM, then it makes the updates to the Real DOM all at once.
- Whenever setState() method is called on any component, the component gets re-rendered.
- Whenever setState() method is called, new Virtual DOM is created.
- ReactJS maintains two virtual DOMs, one with the updated state Virtual DOM and other with the previous state Virtual DOM.
- Reconciliation: ReactJS uses 'diff' algorithm to compare both the Virtual DOMs to find the minimum number of steps to update the Real DOM. 
- Batch Update: During the event loop, there is exactly one time when the Real DOM is being painted.

___________________________________________________________________________________________________________________________________________

* Uncontrolled elements:
- Initial value is not set.
- refs are used.
- no onChange handler.

* Controlled elements:
- Set the initial value as a prop.
- onChange handler.
- Synchronized with the state always.  

___________________________________________________________________________________________________________________________________________

* Higher order components:
- It's a function that takes a component as an argument and returns a component.
- It transforms the sent component, by adding new props.
- It's a pure function.

* When to use a HOC:
- Share the same functionality across multiple components (Reusability). Eg. state abstraction.

___________________________________________________________________________________________________________________________________________

* Pure component:
- It's just a normal component, except it handles shouldComponentUpdate() for you.
- It'll do a shallow comparision on props and state.

___________________________________________________________________________________________________________________________________________

* Keys in React:
- It's used to uniquely identify the components.
- It's useful when there're dynamically created components.
- It boosts the performance, by preventing the re-rendering. 
- Keys make the reconciliation more efficient.
___________________________________________________________________________________________________________________________________________

* PropTypes *
___________________________________________________________________________________________________________________________________________

** Axios **

* Axios is a promise-based Ajax tool.

___________________________________________________________________________________________________________________________________________

** React Router (v4)**

- only react-router-dom is used. react-router is not needed.

* <BrowserRouter>: Used for dynamic websites.
* <HashRouter>: Used for static websites.
* <MemoryRouter>

* history: It's an object that keeps track of current location.
* location object

* Context.

* <Route>:
- It is the building block of react router.
- It renders the content based on the current location's pathname.

* <Switch>:
- It's used when you want to display only a single route to be rendered amongst the several defined routes.
- Renders the first match.

- exact and strict.
- path-to-regexp.

* Three ways:
1. <Route path="/users" component={}  />.
2. <Route path="/users" render={}  />.
- Inline rendering.
- We can pass extra props to a component. 
3. <Route path="/users" children={}  />.
- route will always be rendered, regardless of matching.

* Difference between component and render.
- render is slower than component.
- component uses React.createElement().
- render uses function call.

- When the route's "path" prop matches with the current location, an object called "match" is created.

* match object has the following properties:
* url - The matched part of current location's pathname.
* path - The route's path.
* isExact - path === pathname.
* params - An object that has the route parameters/ path parameters.

* Nested Routes.

* <Link to=" " /> or <Link to={{ }}> (location object goes here):
- Navigate between pages without reloading. 

* <NavLink to=" " />
- Link highlighting.

___________________________________________________________________________________________________________________________________________

** Redux **

- Flux is a data architecture or data pattern.
- Flux enforces Uni-directional data flow.
- action --> dispatcher --> store --> view.
- State is immutable in Flux.


- Redux is a state management framework.
- Redux is an implementation of Flux.
- State is immutable in Redux.
- Redux follows Uni-directional data flow.


** Three principles of Redux **
1. Single source of truth - The state of your the application is stored in an object tree within a single store.
2. State is read-only - State is immutable. The only way to change the state is to dispatch an action.
3. Changes are made with pure functions - reducers.


** Differences between Flux and Redux **
- Has multiple stores.
- Has dispatchers.
- No reducers.

vs.

- Has a single store.
- No dispatchers.
- Has reducers.

___________________________________________________________________________________________________________________________________________

** Components of Redux **

* Action:
- It describes what has happened.
- It's a JS object that has a "type" property. 
- When we want to change the state, we should dispatch an action. We're notifying the store.

* Action creator:
- It's a function in which an action is wrapped.

* Store:
- It holds the state of application.

* createStore():
- Creates the redux store.

- store.dispatch(action).
- store.getState().

* store.subscribe(listener):
- listener gets called when the store's state is changed.

* store.getState():
- 

* Reducer:
- It's a pure function that takes currentState and action as the arguments and returns the newState.
- It doesn't mutate the currentState.
- combineReducers().
- It has a switch statement.

___________________________________________________________________________________________________________________________________________

** react-redux **
- It's a library that connects React with Redux.

* connect():
- It connects a react component to the redux store.
- It takes at least one argument.

* mapStateToProps():
- It passes a part of store's state to the props of a react component.
- It connects a part of redux state  
- React component'll have the access to the exact part of redux store, it needs.

* mapDispatchToProps():
- It passes redux actions to the props of a react component.
- With this, a react component can dispatch actions.

* Provider:
- It's a higher order component that is used to connect a react application with redux.
- Whole application is wrapped inside this component.

___________________________________________________________________________________________________________________________________________


** Resources **

* https://www.valentinog.com/blog/react-redux-tutorial-beginners/
* https://css-tricks.com/learning-react-redux/
* https://redux.js.org/
* https://www.smashingmagazine.com/2016/06/an-introduction-to-redux/
* https://egghead.io/lessons/react-redux-pure-and-impure-functions

___________________________________________________________________________________________________________________________________________

* Why a state manager is required?

- Component-to-component communication, where there is no direct parent-child relationship is error prone.
- Components "dispatch" state changes to the store, not directly to other components. The components that need to be aware of state changes can "subscribe" to the store.

___________________________________________________________________________________________________________________________________________

*** Flux ***

- Flux is a data flow architecture/pattern.
- It enforces uni-directional data flow.

* Data flow in Flux:
 Action --> Dispatcher --> Store.

___________________________________________________________________________________________________________________________________________

*** Redux ***

- It's a state management library.
- It's an implementation of Flux (data flow architecture).
- It should be used only in complex applications.
- It uses the concepts of Functional programming.

___________________________________________________________________________________________________________________________________________

** Flux vs. Redux **

- Multiple stores. - Single store.
- State is mutable. - State is immutable.
- Business logic is present in store. - Business logic is present in reducer.
- No Reducer. - Reducer.
- Dispatcher. - No Dispatcher.


___________________________________________________________________________________________________________________________________________


* Principles of Redux:
1. Single source of truth.
- The state of the entire application is stored in an object / state tree within a single store. The single state tree makes it easier to keep track of changes over time and debug the application.
2. State is immutable (read-only). The only way to change the state is to emit an action.
3. Changes are made with pure functions called reducers.

___________________________________________________________________________________________________________________________________________

** Redux components **

* Action:
- It’s an JS object that describes what has happened.
- It has type and payload properties.
- It can be wrapped in a action creator function.

* Action creators return actions.

* Reducer:
- It is a function that changes the state, based on the action.
- It's a pure function that takes previous state and action as arguments and returns the next state.
- It doesn't mutate the previous state, since the state is immutable in Redux.
- It has a switch statement on action's type property.
- returns Object.assign() or object spread syntax.
- API calls must not be placed inside this.

* Actions only describe what happened, but don't describe how the application's state changes.

* Store:
- It's the place where the state of whole application lives.

* View:
- It displays the data provided by the store.

___________________________________________________________________________________________________________________________________________

* Pure function in JavaScript: (Functional programming concept)
- It doesn't transform the passed argument. Its arguments should be considered "immutable", meaning they should not be changed.
- Its return value depends solely on the values of its parameters.
- Calling a pure function with the same set of arguments will always return the same value.
- No side-effects.
- Eg. Array.prototype.concat().

* Benefits of pure functions:
- Easier to test, maintain and debug.

___________________________________________________________________________________________________________________________________________

* Three helper methods of store object are:
- store.getState() - It returns the current state of the application.
- store.dispatch(action) - It's used to dispatch an action.
- store.subscribe(listener) - It provides a callback function which gets executed when the state changes.

** methods of redux:
- combineReducers().
- createStore().

___________________________________________________________________________________________________________________________________________

** react-redux (v5) **

- It's a library that is used to connect React with Redux.

* <Provider>:
- It's a higher order component that connects the whole application with the redux store.
- The whole application is wrapped inside this component.
- Syntax: 
 <Provider store={}>
  	<App />
 </Provider>

* connect(): 
- It connects a React component with the redux store.
- mapStateToProps() and mapDispatchToProps() can be passed as arguments to connect(). 
- It takes at least one argument.
- Syntax: connect( mapStateToProps, mapDispatchToProps)(componentName);

* mapStateToProps():
- It connects an exact part of redux state to the props of a react component, what it needs.
- A react component gets the access to a part of redux store, it needs.

* mapDispatchToProps():
- It connects redux actions to the props of a react component.
- With this, a react component can dispatch the actions.

___________________________________________________________________________________________________________________________________________

** Redux Thunk **

- Its' a middleware that is used to handle asynchronous redux actions.
___________________________________________________________________________________________________________________________________________